import React, { useState, useRef, useEffect } from 'react';
import { Layer, AdvancedConfig } from '../types';
import Button from './Button';
import LayerPreview from './LayerPreview';
import { X, RefreshCw, Layers, Image as ImageIcon, Check, Trash2, MousePointer2, Scissors, PenTool, Eraser } from 'lucide-react';
import { splitByLasso } from '../services/imageProcessing';

/* --- CHOP MODAL --- */
interface ChopModalProps {
  layer: Layer;
  onClose: () => void;
  onGenerate: (config: AdvancedConfig, sublayerCount: number) => Promise<Layer[]>;
  onApply: (keptLayers: Layer[], layersToMerge: Layer[]) => void;
}

export const ChopModal: React.FC<ChopModalProps> = ({ layer, onClose, onGenerate, onApply }) => {
    const [mode, setMode] = useState<'auto' | 'manual'>('auto');
    
    // Auto Mode State
    const [method, setMethod] = useState<'vector' | 'raster'>('raster');
    const [sublayerCount, setSublayerCount] = useState(3);
    const [autoGeneratedLayers, setAutoGeneratedLayers] = useState<Layer[]>([]);
    const [keepState, setKeepState] = useState<boolean[]>([]);
    const [deletedState, setDeletedState] = useState<boolean[]>([]);
    const [loading, setLoading] = useState(false);

    // Manual Mode State
    const [manualLayers, setManualLayers] = useState<Layer[]>([{ ...layer, id: 'base-manual', visible: true }]); // Start with current layer
    const [activeManualIndex, setActiveManualIndex] = useState(0); // Which layer we are chopping
    const [lassoPoints, setLassoPoints] = useState<{x: number, y: number}[]>([]);
    const [isDrawing, setIsDrawing] = useState(false);
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const containerRef = useRef<HTMLDivElement>(null);

    // --- AUTO MODE HANDLERS ---
    const handleGenerate = async () => {
        setLoading(true);
        const tempConfig: AdvancedConfig = {
            sampleSize: 10000, inkOpacity: 1, kL: 1, kC: 1, kH: 1,
            separationMethod: 'ciede2000', separationType: method,
            speckleSize: 0, erosionAmount: 0,
            halftoneType: 'am', halftoneLpi: 50, halftoneAngle: 22.5, gamma: 1.0
        };
        try {
            const subs = await onGenerate(tempConfig, sublayerCount);
            setAutoGeneratedLayers(subs);
            setKeepState(new Array(subs.length).fill(true));
            setDeletedState(new Array(subs.length).fill(false));
        } catch (e) {
            console.error(e);
            alert("Failed to generate sublayers");
        } finally {
            setLoading(false);
        }
    };

    const handleApplyAuto = () => {
        const kept: Layer[] = [];
        const toMerge: Layer[] = [];
        autoGeneratedLayers.forEach((l, idx) => {
            if (deletedState[idx]) return;
            if (keepState[idx]) kept.push(l);
            else toMerge.push(l);
        });
        onApply(kept, toMerge); 
    };

    // --- MANUAL MODE HANDLERS (LASSO) ---

    // Draw logic for the manual editor
    useEffect(() => {
        if (mode !== 'manual' || !canvasRef.current) return;
        
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        const targetLayer = manualLayers[activeManualIndex];
        
        // 1. Draw the current active layer image
        // We need to scale it to fit the canvas display if needed, but for simplicity here we assume 
        // the canvas renders at image resolution (scaled via CSS).
        // Best approach: Canvas internal resolution = Image resolution.
        
        canvas.width = targetLayer.data.width;
        canvas.height = targetLayer.data.height;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Background checkerboard simulation if transparent (optional, expensive in loop)
        // Draw the Image Data
        ctx.putImageData(targetLayer.data, 0, 0);

        // 2. Draw Lasso Path
        if (lassoPoints.length > 0) {
            ctx.strokeStyle = '#00ff00'; // Green selection
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
            for (let i = 1; i < lassoPoints.length; i++) {
                ctx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
            }
            if (!isDrawing && lassoPoints.length > 2) {
                ctx.closePath(); // Close it visually if done
                ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.fill();
            }
            ctx.stroke();
        }

    }, [mode, manualLayers, activeManualIndex, lassoPoints, isDrawing]);

    const getScaledCoordinates = (e: React.MouseEvent) => {
        const canvas = canvasRef.current;
        if (!canvas) return { x: 0, y: 0 };
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    };

    const handleMouseDown = (e: React.MouseEvent) => {
        if (mode !== 'manual') return;
        setIsDrawing(true);
        setLassoPoints([getScaledCoordinates(e)]);
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDrawing) return;
        setLassoPoints(prev => [...prev, getScaledCoordinates(e)]);
    };

    const handleMouseUp = () => {
        setIsDrawing(false);
        // Automatically close path logic is visual, handled in render
    };

    const handleManualSplit = () => {
        if (lassoPoints.length < 3) return;
        
        const targetLayer = manualLayers[activeManualIndex];
        
        // Use the new service function
        try {
            const [inside, outside] = splitByLasso(targetLayer.data, lassoPoints);
            
            // Create new layer objects
            const newLayerInside: Layer = {
                id: `lasso-inside-${Date.now()}`,
                color: targetLayer.color,
                data: inside,
                visible: true
            };
            
            const newLayerOutside: Layer = {
                id: `lasso-outside-${Date.now()}`,
                color: targetLayer.color,
                data: outside,
                visible: true
            };

            // Update state: Replace the active layer with 'Outside' (remaining), add 'Inside' as new layer
            const updatedLayers = [...manualLayers];
            // Remove the original
            updatedLayers.splice(activeManualIndex, 1, newLayerOutside, newLayerInside);
            
            setManualLayers(updatedLayers);
            setLassoPoints([]); // Reset lasso
            setActiveManualIndex(updatedLayers.length - 1); // Select the new "Inside" layer? Or stay on remaining?
            // Let's stay on the "Outside" (Remaining) usually to keep cleaning, which is index `activeManualIndex` (now occupied by Outside)
            setActiveManualIndex(activeManualIndex);

        } catch (err) {
            console.error(err);
            alert("Failed to split layer");
        }
    };

    const handleManualDelete = () => {
         if (lassoPoints.length < 3) return;
         // Logic similar to split, but we just discard the 'inside' part
         const targetLayer = manualLayers[activeManualIndex];
         const [, outside] = splitByLasso(targetLayer.data, lassoPoints);
         
         const newLayerOutside: Layer = {
             ...targetLayer,
             data: outside
         };
         
         const updatedLayers = [...manualLayers];
         updatedLayers[activeManualIndex] = newLayerOutside;
         setManualLayers(updatedLayers);
         setLassoPoints([]);
    };

    const handleApplyManual = () => {
        // Return all manual layers as "Kept", none to merge (unless we implement merge logic here too)
        onApply(manualLayers, []);
    };


    return (
        <div className="bg-gray-100 rounded-lg shadow-2xl w-full max-w-5xl flex flex-col overflow-hidden max-h-[95vh] h-[800px]">
            <div className="bg-gray-200 px-4 py-2 border-b border-gray-300 flex justify-between items-center shrink-0">
                <div className="flex gap-4">
                    <h3 className="text-lg font-bold text-gray-800 flex items-center gap-2">
                        <Scissors className="w-5 h-5" /> Chop / Split Layer
                    </h3>
                    <div className="flex bg-white rounded-lg p-1 border border-gray-300">
                        <button 
                            onClick={() => setMode('auto')}
                            className={`px-3 py-1 rounded text-xs font-bold uppercase transition-colors ${mode === 'auto' ? 'bg-indigo-600 text-white shadow-sm' : 'text-gray-500 hover:bg-gray-100'}`}
                        >
                            Auto Separation
                        </button>
                        <button 
                             onClick={() => setMode('manual')}
                             className={`px-3 py-1 rounded text-xs font-bold uppercase transition-colors flex items-center gap-1 ${mode === 'manual' ? 'bg-indigo-600 text-white shadow-sm' : 'text-gray-500 hover:bg-gray-100'}`}
                        >
                            <PenTool className="w-3 h-3" /> Manual Lasso
                        </button>
                    </div>
                </div>
                <button onClick={onClose}><X className="text-gray-500 hover:text-red-500" /></button>
            </div>
            
            {mode === 'auto' ? (
                /* --- AUTO CONTENT (PREVIOUS UI) --- */
                <div className="flex-1 flex flex-col min-h-0">
                     <div className="p-4 bg-blue-50/50 border-b border-gray-200 text-sm text-gray-600 shrink-0">
                        <strong>Auto-Split:</strong> Algorithmically divide this layer into sub-shades using color distance (CIEDE2000).
                    </div>
                    <div className="p-6 space-y-6 overflow-y-auto">
                         <div className="flex items-end gap-4 bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                            <div className="flex-1 space-y-2">
                                <label className="text-xs font-bold text-gray-500 uppercase">Method</label>
                                <select 
                                    value={method} 
                                    onChange={(e) => setMethod(e.target.value as any)}
                                    className="w-full bg-gray-50 border border-gray-300 rounded p-2 text-gray-800 text-sm"
                                >
                                    <option value="vector">Vector (Hard Edges)</option>
                                    <option value="raster">Raster (Gradients)</option>
                                </select>
                            </div>
                            <div className="w-32 space-y-2">
                                <label className="text-xs font-bold text-gray-500 uppercase">Count</label>
                                <input 
                                    type="number" min="2" max="6" 
                                    value={sublayerCount}
                                    onChange={(e) => setSublayerCount(parseInt(e.target.value))}
                                    className="w-full bg-gray-50 border border-gray-300 rounded p-2 text-gray-800 text-sm"
                                />
                            </div>
                            <Button onClick={handleGenerate} isLoading={loading} className="bg-indigo-600 hover:bg-indigo-700 h-10">
                                <RefreshCw className="w-4 h-4 mr-2" /> Generate
                            </Button>
                        </div>
                         {autoGeneratedLayers.length > 0 && (
                            <div className="grid grid-cols-3 gap-4 pb-4">
                                {autoGeneratedLayers.map((sub, idx) => (
                                    !deletedState[idx] && (
                                        <div key={idx} className={`bg-white rounded-lg border-2 overflow-hidden transition-all relative group ${keepState[idx] ? 'border-indigo-500 shadow-md' : 'border-gray-200 opacity-60'}`}>
                                            <div className="aspect-square bg-gray-100 relative">
                                                <LayerPreview imageData={sub.data} width={sub.data.width} height={sub.data.height} tint={sub.color.hex} />
                                            </div>
                                            <div className="p-2 flex flex-col gap-2 border-t border-gray-100">
                                                 <div className="flex justify-between items-center">
                                                    <span className="text-[10px] font-bold text-gray-500">Sublayer {idx + 1}</span>
                                                    <button onClick={() => { const d = [...deletedState]; d[idx] = true; setDeletedState(d); }} className="text-gray-300 hover:text-red-500"><Trash2 className="w-3 h-3"/></button>
                                                </div>
                                                <button 
                                                    onClick={() => { const k = [...keepState]; k[idx] = !k[idx]; setKeepState(k); }}
                                                    className={`w-full py-1 text-[10px] font-bold uppercase rounded flex items-center justify-center gap-1 ${keepState[idx] ? 'bg-indigo-100 text-indigo-700' : 'bg-gray-100 text-gray-500'}`}
                                                >
                                                    {keepState[idx] ? <Check className="w-3 h-3"/> : null} {keepState[idx] ? 'Keep' : 'Merge'}
                                                </button>
                                            </div>
                                        </div>
                                    )
                                ))}
                            </div>
                        )}
                    </div>
                    <div className="bg-gray-200 p-4 border-t border-gray-300 flex justify-end gap-3 shrink-0">
                        <Button variant="secondary" onClick={onClose} className="text-gray-700 bg-white border border-gray-300">Cancel</Button>
                        <Button onClick={handleApplyAuto} disabled={autoGeneratedLayers.length === 0} className="bg-gray-800 text-white">Apply</Button>
                    </div>
                </div>
            ) : (
                /* --- MANUAL CONTENT (LASSO) --- */
                <div className="flex-1 flex flex-col min-h-0 bg-gray-900">
                     <div className="p-2 bg-gray-800 border-b border-gray-700 text-xs text-gray-400 flex items-center justify-between shrink-0">
                         <div className="flex items-center gap-4">
                            <span className="flex items-center gap-2"><MousePointer2 className="w-3 h-3" /> Draw selection to cut/delete</span>
                            <div className="h-4 w-px bg-gray-600"></div>
                            <span className="text-yellow-500 font-bold">Active: {activeManualIndex + 1}/{manualLayers.length}</span>
                         </div>
                         <div className="flex gap-2">
                             <Button size="sm" variant="secondary" disabled={lassoPoints.length < 3} onClick={handleManualDelete} className="text-xs py-1 h-7 bg-red-900/50 hover:bg-red-800 border-red-800 text-red-200">
                                 <Eraser className="w-3 h-3 mr-1" /> Delete Area
                             </Button>
                             <Button size="sm" variant="primary" disabled={lassoPoints.length < 3} onClick={handleManualSplit} className="text-xs py-1 h-7 bg-blue-600 hover:bg-blue-500">
                                 <Scissors className="w-3 h-3 mr-1" /> Split to New Layer
                             </Button>
                         </div>
                    </div>

                    <div className="flex-1 flex overflow-hidden">
                        {/* LEFT: CANVAS EDITOR */}
                        <div className="flex-1 relative bg-[url('https://www.transparenttextures.com/patterns/checkerboard.png')] bg-gray-800 overflow-auto flex items-center justify-center p-8" ref={containerRef}>
                            <canvas 
                                ref={canvasRef}
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                className="shadow-2xl cursor-crosshair border border-gray-600 max-w-none"
                                style={{ 
                                    // We let CSS handle scaling for view, but ideally we should control zoom
                                    maxHeight: '100%',
                                    maxWidth: '100%'
                                }}
                            />
                        </div>

                        {/* RIGHT: LAYER LIST */}
                        <div className="w-48 bg-gray-800 border-l border-gray-700 flex flex-col">
                            <div className="p-2 text-xs font-bold text-gray-500 uppercase tracking-wider bg-gray-900">Working Layers</div>
                            <div className="flex-1 overflow-y-auto p-2 space-y-2">
                                {manualLayers.map((l, idx) => (
                                    <div 
                                        key={idx} 
                                        onClick={() => { setActiveManualIndex(idx); setLassoPoints([]); }}
                                        className={`p-2 rounded border cursor-pointer transition-all ${activeManualIndex === idx ? 'bg-blue-600/20 border-blue-500' : 'bg-gray-700 border-gray-600 opacity-60 hover:opacity-100'}`}
                                    >
                                        <div className="aspect-video bg-gray-900 mb-1 rounded overflow-hidden pointer-events-none">
                                            <LayerPreview imageData={l.data} width={l.data.width} height={l.data.height} tint={l.color.hex} />
                                        </div>
                                        <div className="flex justify-between items-center">
                                            <span className="text-[10px] text-gray-300 font-mono truncate w-20">Part {idx+1}</span>
                                            {manualLayers.length > 1 && (
                                                <button 
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        const remaining = manualLayers.filter((_, i) => i !== idx);
                                                        setManualLayers(remaining);
                                                        setActiveManualIndex(0);
                                                    }}
                                                    className="text-gray-500 hover:text-red-400"
                                                >
                                                    <X className="w-3 h-3"/>
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    <div className="bg-gray-800 p-3 border-t border-gray-700 flex justify-end gap-3 shrink-0">
                         <Button variant="secondary" onClick={onClose} className="text-gray-400 hover:text-white">Cancel</Button>
                         <Button onClick={handleApplyManual} className="bg-green-600 hover:bg-green-500 text-white">Confirm Changes</Button>
                    </div>
                </div>
            )}
        </div>
    );
};

/* --- MERGE MODAL --- */
interface MergeModalProps {
    targetLayer: Layer;
    allLayers: Layer[];
    onClose: () => void;
    onMerge: (layersToMerge: Layer[], finalColorHex: string) => void;
}

export const MergeModal: React.FC<MergeModalProps> = ({ targetLayer, allLayers, onClose, onMerge }) => {
    const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
    const [finalColorHex, setFinalColorHex] = useState<string>(targetLayer.color.hex);
    
    // Filter out the current layer from the list
    const otherLayers = allLayers.filter(l => l.id !== targetLayer.id);

    const toggleLayer = (id: string) => {
        const newSet = new Set(selectedIds);
        if (newSet.has(id)) newSet.delete(id);
        else newSet.add(id);
        setSelectedIds(newSet);
    };

    const handleMerge = () => {
        const layersToMerge = otherLayers.filter(l => selectedIds.has(l.id));
        onMerge(layersToMerge, finalColorHex);
    };

    return (
        <div className="bg-gray-100 rounded-lg shadow-2xl w-full max-w-4xl flex flex-col overflow-hidden max-h-[90vh]">
             <div className="bg-gray-200 p-4 border-b border-gray-300 flex justify-between items-center">
                <h3 className="text-lg font-bold text-gray-800">Merge Layers with {targetLayer.color.hex}</h3>
                <button onClick={onClose}><X className="text-gray-500 hover:text-red-500" /></button>
            </div>
             <div className="p-6 bg-yellow-50/50 border-b border-gray-200 text-sm text-gray-600">
                <strong>Instructions:</strong> Select layers to merge with the current layer. The selected layers will be combined into a single layer. Select which color the final layer should take.
            </div>

            <div className="p-6 grid grid-cols-2 gap-8">
                {/* Left: Layer Selection */}
                <div className="space-y-4">
                     <h4 className="text-xs font-bold text-gray-500 uppercase">Select Layers to Merge</h4>
                     <div className="grid grid-cols-2 gap-3 max-h-96 overflow-y-auto">
                        {otherLayers.map(layer => (
                            <div 
                                key={layer.id} 
                                onClick={() => toggleLayer(layer.id)}
                                className={`cursor-pointer rounded-lg border-2 p-3 transition-all ${selectedIds.has(layer.id) ? 'border-indigo-500 bg-indigo-50' : 'border-gray-200 bg-white hover:border-gray-300'}`}
                            >
                                <div className="aspect-video bg-gray-100 mb-2 rounded overflow-hidden">
                                     <LayerPreview imageData={layer.data} width={layer.data.width} height={layer.data.height} tint={layer.color.hex} />
                                </div>
                                <div className="text-center">
                                    <div className="w-3 h-3 rounded-full inline-block mr-2" style={{backgroundColor: layer.color.hex}}></div>
                                    <span className="text-xs font-mono font-bold text-gray-600">{layer.color.hex}</span>
                                </div>
                            </div>
                        ))}
                     </div>
                </div>

                {/* Right: Color Selection */}
                <div className="space-y-4">
                    <h4 className="text-xs font-bold text-gray-500 uppercase">Final Layer Color</h4>
                    <div className="space-y-2">
                        {/* Current Layer Option */}
                        <label className={`flex items-center gap-3 p-3 rounded border cursor-pointer ${finalColorHex === targetLayer.color.hex ? 'bg-white border-indigo-500 shadow-sm' : 'border-transparent hover:bg-gray-200'}`}>
                            <input 
                                type="radio" 
                                name="finalColor" 
                                checked={finalColorHex === targetLayer.color.hex} 
                                onChange={() => setFinalColorHex(targetLayer.color.hex)}
                                className="text-indigo-600"
                            />
                            <div className="w-6 h-6 rounded border border-gray-300" style={{backgroundColor: targetLayer.color.hex}}></div>
                            <span className="text-sm font-bold text-gray-700">Current ({targetLayer.color.hex})</span>
                        </label>

                        {/* Selected Layers Options */}
                        {Array.from(selectedIds).map(id => {
                            const l = otherLayers.find(ol => ol.id === id);
                            if (!l) return null;
                            return (
                                <label key={l.id} className={`flex items-center gap-3 p-3 rounded border cursor-pointer ${finalColorHex === l.color.hex ? 'bg-white border-indigo-500 shadow-sm' : 'border-transparent hover:bg-gray-200'}`}>
                                    <input 
                                        type="radio" 
                                        name="finalColor" 
                                        checked={finalColorHex === l.color.hex} 
                                        onChange={() => setFinalColorHex(l.color.hex)}
                                        className="text-indigo-600"
                                    />
                                    <div className="w-6 h-6 rounded border border-gray-300" style={{backgroundColor: l.color.hex}}></div>
                                    <span className="text-sm font-bold text-gray-700">Merge Target ({l.color.hex})</span>
                                </label>
                            );
                        })}
                    </div>
                </div>
            </div>

            <div className="bg-gray-200 p-4 border-t border-gray-300 flex justify-end gap-3 mt-auto">
                <Button variant="secondary" onClick={onClose} className="text-gray-700 bg-white border border-gray-300 hover:bg-gray-50">Cancel</Button>
                <Button 
                    onClick={handleMerge} 
                    disabled={selectedIds.size === 0} 
                    className="bg-gray-800 text-white hover:bg-gray-700"
                >
                    Merge Selected Layers
                </Button>
            </div>
        </div>
    );
};

/* --- EDIT COLOR MODAL --- */
interface EditColorModalProps {
    layer: Layer;
    onClose: () => void;
    onSave: (newHex: string) => void;
}

export const EditColorModal: React.FC<EditColorModalProps> = ({ layer, onClose, onSave }) => {
    const [hex, setHex] = useState(layer.color.hex);

    return (
        <div className="bg-gray-100 rounded-lg shadow-2xl w-full max-w-md flex flex-col overflow-hidden">
            <div className="bg-gray-200 p-4 border-b border-gray-300 flex justify-between items-center">
                <h3 className="text-lg font-bold text-gray-800">Edit Layer Color</h3>
                <button onClick={onClose}><X className="text-gray-500 hover:text-red-500" /></button>
            </div>
             <div className="p-4 bg-purple-50/50 border-b border-gray-200 text-xs text-gray-600">
                <strong>Instructions:</strong> Change the color of this layer. The change will be applied to both the layer and the separated image.
            </div>
            
            <div className="p-6 space-y-6">
                <div className="flex flex-col gap-2">
                     <label className="text-xs font-bold text-gray-500 uppercase">Color Picker</label>
                     <input 
                        type="color" 
                        value={hex} 
                        onChange={(e) => setHex(e.target.value)} 
                        className="w-full h-12 p-1 bg-white border border-gray-300 rounded cursor-pointer"
                    />
                </div>
                <div className="flex flex-col gap-2">
                     <label className="text-xs font-bold text-gray-500 uppercase">Hex Color</label>
                     <input 
                        type="text" 
                        value={hex} 
                        onChange={(e) => setHex(e.target.value)} 
                        className="w-full p-2 bg-white border border-gray-300 rounded font-mono text-gray-800"
                    />
                </div>
                <div className="bg-black p-4 rounded text-center">
                    <span className="text-white font-bold" style={{color: hex}}>Preview Text on Black</span>
                    <div className="w-full h-8 mt-2 rounded" style={{backgroundColor: hex}}></div>
                </div>
            </div>

            <div className="bg-gray-200 p-4 border-t border-gray-300 flex justify-end gap-3">
                <Button variant="secondary" onClick={onClose} className="text-gray-700 bg-white border border-gray-300 hover:bg-gray-50">Cancel</Button>
                <Button onClick={() => onSave(hex)} className="bg-fuchsia-700 text-white hover:bg-fuchsia-800">
                    Apply Color Change
                </Button>
            </div>
        </div>
    );
};